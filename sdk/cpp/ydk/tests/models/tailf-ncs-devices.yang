submodule tailf-ncs-devices {

  belongs-to tailf-ncs {
    prefix ncs;
  }

  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }
  import tailf-common {
    prefix tailf;
  }
  import tailf-ncs-ned {
    prefix ned;
  }

  include tailf-ncs-common;
  include tailf-ncs-cluster;
  include tailf-ncs-ssh;

  organization "Tail-f Systems";

  description
    "This submodule contains a collection of YANG definitions for
     configuring and monitoring managed devices in NCS.";

  revision 2015-06-16 {
    description
      "Released as part of NCS-4.0.

       Added /devices/device/platform container for vendor specific
       operational data like operating system, version etc.

       Added /devices/global-settings/atomic.

       Added action 'set-atomic-behaviour' to /devices/commit-queue.

       Added action 'set-atomic-behaviour' to
       /devices/commit-queue/queue-item.";
  }

  revision 2015-03-19 {
    description
      "Released as part of NCS-3.4.

       Changed /devices/device/netconf-notifications/subscription/local-user
         from config:false to config:true and made it mandatory.";
  }

  revision 2014-11-19 {
    description
      "Released as part of NCS-3.3.

       Changed input and output of /devices/device/apply-template and
         /devices/device-group/apply-template. New optional input
         parameters are: 'suppress-positive-result' and
         'accept-empty-capabilities'. The output is now structured
         with separate result for each affected device.

       Added grouping commit-queue-options.

       Changed the grouping ncs-commit-params.
         Added container commit-queue which uses commit-queue-options.
         'async-commit-queue' has changed to 'commit-queue/async',
         'sync-commit-queue' has changed to 'commit-queue/sync' and
         'bypass-commit-queue' has changed to 'commit-queue/bypass'.
         Added the leaf 'commit-queue/tag'. Added the container
         'commit-queue/lock'.

       Changed the grouping ncs-commit-result.
         Added the leaf 'commit-queue/tag'.

       Changed the name of
         /devices/commit-queues to /devices/commit-queue.

       Changed names of actions in /devices/commit-queue. The action
         'clear-queue' has changed to 'clear'.
         The action 'prune-queue' has changed to 'prune'. The input
         parameter has changed from 'devices' to 'device'.

         The action 'wait-queue-empty' has changed
         to 'wait-until-empty'. The default for 'wait-queue-empty' has
         changed and is now 'infinity'.

       Added action 'add-lock' to /devices/commit-queue.

       Changes in list /devices/commit-queue/queue-item/:
         Changed data type of leaf 'id' from int64 to uint64.
         Added leaf 'tag'.
         Change name of leaf-list 'done' to 'completed'
         Added list 'remote-queue-item' for remote queue items.
         Removed action 'run'.
         Added actions 'lock' and 'unlock'.
         Added action 'prune'.

       Added ncs-commit-queue-progress-event notification.";
  }

  revision 2014-06-30 {
    description
      "Released as part of NCS-3.2.

       Added grouping ncs-commit-params.

       Added use of grouping ssh-host-keys from submodule tailf-ncs-ssh,
         creating /devices/device/ssh.

       Added /devices/device/fetch-ssh-host-keys
         and /devices/device-group/fetch-ssh-host-keys actions.

       Replaced leaf public-key in grouping remote-user-remote-auth with use
         of grouping public-key-auth from submodule tailf-ncs-ssh,
         affecting /devices/authgroups/group/default-map/public-key
         and /devices/authgroups/group/umap/public-key.

       Added use of grouping ssh-host-keys from submodule tailf-ncs-ssh,
         creating /devices/device/ssh.

       Added /devices/device/disconnect.

       Changed the /device/commit-queue/wating-for to a list, in order to
         handle remote nodes.

       Added an enum 'locked' to
         /devices/device/netconf-notifications/subscription/failure-reason.

       Changed the name of
         /devices/commit-queues/queue-item/connection-failures to
         transient-errors.";
  }

  revision 2014-05-20 {
    description
      "Released as part of NCS-3.1.1.1.

       Changed the names of some /devices/commit-queues/queue-item/status
         enumeration.";
  }

  revision 2014-04-02 {
    description
      "Released as part of NCS-3.1.

       Added /devices/global-settings/commit-retries.
       Added /devices/global-settings/ned-settings.
       Added /devices/profiles.
       Added /devices/device/device-profile.
       Added /devices/device/ned-settings.";
  }

  revision 2013-11-12 {
    description
      "Released as part of NCS-3.0.

       Added grouping check-yang-modules-grouping and its use
       in devices and device-groups.

       Added grouping check-yang-modules-result and its use
       in devices and device-groups.

       Added action check-yang-modules to device.";
  }

  revision 2013-06-18 {
    description
      "Released as part of NCS-2.3.

       Added /device/device/location and
        /device/device-group/location.

       Deprecated the 3 different sync actions all/group/device and
         replaced them with two new actions sync-to and sync-from.
         The sync-to action has an additional dry-run parameter.";
  }

  revision 2013-03-12 {
    description
      "Released as part of NCS-2.2.

       Made /devices/device/device-type mandatory.
       Added /devices/commit-queues.
       Added /devices/global-settings/out-of-sync-commit-behaviour.";
  }

  revision 2012-11-13 {
    description
      "Released as part of NCS-2.1.

       Removed /devices/device/connection.";
  }

  revision 2012-08-30 {
    description
      "Released as part of NCS-2.0.

       Added /devices/device-group/member.

       Added /devices/device/live-status-protocol.
       Added /devices/device/connect-timeout.
       Added /devices/device/read-timeout.
       Added /devices/device/write-timeout.";
  }

  typedef oper-state {
    type enumeration {
      enum enabled {
        tailf:code-name 'oper_enabled';
      }
      enum disabled {
        tailf:code-name 'oper_disabled';
      }
    }
  }

  typedef oper-state-error-tag {
    type enumeration {
      enum noconnection {
        description
          "Cannot connect to the configured ip and port.";
      }
      enum locked {
        description
          "Administratively locked.";
      }
      enum revision-error {
        description
          "The device has a newer revision of a model than NCS can handle.";
      }
      enum badconfig {
        description
          "The device is misconfigured in some way";
      }
    }
  }

  grouping oper-state {
    leaf oper-state {
      type oper-state;
      default disabled;
      config false;
      tailf:cdb-oper  {
        tailf:persistent false;
      }
    }
    leaf oper-state-error-tag {
      type oper-state-error-tag;
      config false;
      tailf:cdb-oper {
        tailf:persistent false;
      }
    }
    leaf oper-state-hash {
      type uint32;
      config false;
      description
        "Used internally.";
      // Hidden hash to prevent multiple cdb oper writes of
      // the same thing. Optimization.
      tailf:hidden full;
      tailf:cdb-oper {
        tailf:persistent false;
      }
    }
  }

  typedef admin-state {
    type enumeration {
      enum locked {
        description
          "When a device is admistratively locked, it is not possible
           to modify its configuration, and no changes are ever
           pushed to the device.";
        tailf:code-name 'adm_locked';
        tailf:info "Device is locked for config and southbound traffic";
      }
      enum unlocked {
        description
          "Device is assumed to be operational.
           All changes are attempted to be sent southbound.";
        tailf:code-name 'adm_unlocked';
        tailf:info "Device is open for config and southbound traffic";
      }
      enum southbound-locked {
        description
          "It is possible to configure the device, but
           no changes are sent to the device. Useful admin mode
           when pre provisioning devices. This is the default
           when a new device is created.";
        tailf:info "Device is locked for southbound traffic";
      }
    }
  }

  typedef snmp-security-level {
    type enumeration {
      enum no-auth-no-priv { value 1; }
      enum auth-no-priv    { value 2; }
      enum auth-priv       { value 3; }
    }
    reference
      "RFC3411: An Architecture for Describing SNMP Management
                Frameworks";
  }

  typedef snmp-version {
    type enumeration {
      enum v1;
      enum v2c;
      enum v3;
    }
  }

  grouping ncs-commit-params {
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction.  Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
    }
    leaf no-overwrite {
      type empty;
      description
        "This flags means that NCS will check that the data that
         should be modified has not changed on the device compared
         to NCS's view of the data.  This is fine-granular sync check;
         NCS verifies that NCS and the device is in sync regarding
         the data that will be modified.  If they are not in sync,
         the transaction is aborted.";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices.  Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices.  This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
    }
    leaf no-out-of-sync-check {
      type empty;
      description
        "Continue with the transaction even if NCS detects that a device's
         configuration is out of sync.";
    }
    container commit-queue {
      presence "Commit through the commit-queue";
      uses commit-queue-options;
      leaf lock {
        type empty;
        description
          "Place a lock on the resulting queue item. The queue
           item will not be processed until it has been unlocked,
           see the actions 'unlock' and 'lock' in
           /devices/commit-queue/queue-item'.

           No following queue items, using the same devices, will be
           allowed to execute as long as the lock is in place.";
      }
    }
  }
  grouping ncs-commit-result {
    container commit-queue {
      leaf id {
        type leafref {
          path "/ncs:devices/ncs:commit-queue/ncs:queue-item/ncs:id";
        }
        description
          "This leaf is returned if 'commit-queue/async' was given in the
           input parameters, or if 'commit-queue/sync' and 'timeout' was
           given, and the transaction has been queued.";
      }
      leaf tag {
        type string;
        description
          "This leaf is returned if 'commit-queue/tag' was specified in the
           input parameters";
      }
      leaf status {
        type enumeration {
          enum async {
            tailf:code-name "commit_cq_async";
          }
          enum timeout {
            tailf:code-name "commit_cq_timeout";
          }
        }
      }
    }
  }
  grouping connect-grouping {
    tailf:action connect {
      description
        "Set up sessions to all unlocked devices.";
      tailf:info "Set up sessions to all unlocked devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf supress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        leaf override-southbound-locked {
          type empty;
          description
            "When a device is southbound locked, all southbound communication
             is turned off. This flag overrides this for connection
             attempts. Thus, this is a way to update the capabilities
             including revision information for a managed device although
             the device is southbound locked";
        }
      }
      output {
        list connect-result {
          key device;
          leaf device {
            type leafref {
              path '/devices/device/name';
            }
          }
          uses connect-result;
        }
      }
    }
  }

  grouping connect-result {
    description
      "Common result data from a 'connect' action.";

    leaf result {
      type boolean;
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping check-sync-grouping {
    tailf:action check-sync {
      description
        "Perform a cheap sync check, checking if NCS's
         configuration is in sync with all devices' configurations,
         using device-specific mechanisms.  If a device
         doesn't support cheap sync check, 'check-sync' returns
         'unsupported' for that device.";
      tailf:info "Check if the NCS config is in sync with the device";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf supress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices not in sync.";
        }
      }
      output {
        list sync-result {
          key device;
          leaf device {
            type leafref {
              path '/devices/device/name';
            }
          }
          uses check-sync-result;
        }
      }
    }
  }

  grouping check-sync-result {
    description
      "Common result data from a 'check-sync' action.";

    leaf result {
      type enumeration {
        enum unknown {
          description
            "NCS has no record, probably because no
             sync actions has been executed towards the device.
             This is the initial state for a device.";
        }
        enum locked {
          tailf:code-name 'sync_locked';
          description
            "The device is administratively locked, meaning that NCS
             cannot talk to it.";
        }
        enum in-sync {
          tailf:code-name 'in-sync-result';
          description
            "The configuration on the device is in sync with NCS.";
        }
        enum out-of-sync {
          description
            "The device configuration is known to be out of sync, i.e.,
             it has been reconfigured out of band.";
        }
        enum unsupported {
          description
            "The device doesn't have any mechanism to do a cheap
             check-sync, or this mechanism has been disabled.";
        }
        enum error {
          description
            "An error occurred when NCS tried to check the sync status.
             The leaf 'info' contains additional information.";
        }
        enum in-commit-queue {
          description
            "Entries for this device reside in the commit-queue, this
             makes the check-sync operation irrelevant";
        }
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping sync-to-grouping {
    tailf:action sync-to {
      description
        "Synchronize the configuration by pushing to all unlocked devices.

         By default, NCS pushes a minimal diff to the devices.  The
         diff is calculated by reading the configuration from the
         devices and comparing with the configuration in NCS.

         For NETCONF devices, NCS can optionally replace the
         configuration on the devices by sending its own configuration
         without calculating the diff.  Note that NCS will send an
         <edit-config> with the 'replace' option in this case.  This
         means that configuration subtrees that NCS does not know
         about are not replaced.

         If the dry-run option is used, NCS will just report what it
         will do do instead of doing it.";
      tailf:info "Synchronize the config by pushing to the devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf supress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        leaf mode {
          type enumeration {
            enum replace;
          }
          description
            "For NETCONF devices, replace the device configurations
             with the NCS configurations, instead of sending the diff.

             Cannot be used with non-NETCONF devices.";
        }
        leaf dry-run {
          type empty;
          description
            "Report what would be done towards the devices, without
             actually doing anything.  The format of the result depends
             on the device type; the format native to the device is used.";
        }
      }
      output {
        list sync-result {
          key device;
          leaf device {
            type leafref {
              path '/devices/device/name';
            }
          }
          uses sync-to-result;
        }
      }
    }
  }

  grouping sync-to-result {
    description
      "Common result data from a 'sync-to' action.";

    choice sync-res {
      leaf result {
        type boolean;
      }
      leaf data {
        tailf:cli-preformatted;
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping sync-from-grouping {
    tailf:action sync-from {
      description
        "Synchronize the configuration by pulling from all unlocked
         devices.";
      tailf:info "Synchronize the config by pulling from the devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf supress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
      }
      output {
        list sync-result {
          key device;
          leaf device {
            type leafref {
              path '/devices/device/name';
            }
          }
          uses sync-result;
        }
      }
    }
  }

  grouping sync-result {
    description
      "Common result data from a 'sync' action.";

    leaf result {
      type boolean;
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping sync-grouping {
    tailf:action sync {
      status deprecated;
      description
        "Synchronize the configuration by either pulling from or pushing
         to all unlocked devices.

         This action is deprecated.  Use 'sync-to' or 'sync-from' instead.";
      tailf:info "DEPRECATED - use sync-to or sync-from instead";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf direction {
          type enumeration {
            enum to-device;
            enum from-device;
          }
          mandatory true;
        }
        leaf supress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        leaf mode {
          when '../direction = "to-device"';
          type enumeration {
            enum replace;
          }
        }
      }
      output {
        list sync-result {
          key device;
          leaf device {
            type leafref {
              path '/devices/device/name';
            }
          }
          uses sync-result;
        }
      }
    }
  }

  grouping disconnect-grouping {
    tailf:action disconnect {
      description
        "Close all sessions to all devices.";
      tailf:info "Close all sessions to all devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input;
    }
  }

  grouping check-yang-modules-grouping {
    tailf:action check-yang-modules {
      description
        "Check if the device YANG modules loaded by NCS
         have revisions that are compatible with the ones reported
         by the devices.";
      tailf:info "Check if NCS and the devices have compatible YANG modules";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf verbose {
          type empty;
          description
            "Use this to show additional compatibility info.";
        }
        leaf supress-positive-result {
          type empty;
          description
            "Use this to only return devices that have incompatible
             modules.";
        }
      }
      output {
        list device {
          key name;
          leaf name {
            type leafref {
              path '/devices/device/name';
            }
            description
              "Device for which a revision compatibility
               check has been performed.";
          }
          uses check-yang-modules-result;
        }
      }
    }
  }

  grouping check-yang-modules-result {
    description
      "Common result data from a 'check-yang-modules' action.";

    choice compat-res {
      case silent {
        description
          "Present in non-verbose mode.";
        leaf compatible {
          type boolean;
          description
            "Reporting if a device is revision compatible true/false
             in non-verbose mode.";
        }
      }
      case verbose {
        list module {
          description
            "In verbose mode, this is the list of the supported modules for
             a device which are reported as capabilities.";
          key name;
          leaf name {
            type string;
            description "YANG module";
          }
          leaf status {
            description
              "Compatibility status for the YANG module.";
            type enumeration {
              enum supported {
                tailf:code-name module-supported;
                description
                  "Implies that NCS has loaded the yang module with
                   the same revision or a revision of newer date.";
              }
              enum unsupported {
                tailf:code-name module-unsupported;
                description
                  "Implies that NCS has loaded the yang module but the
                   revision is to old.";
              }
              enum not-loaded  {
                tailf:code-name module-not-loaded;
                description
                  "Implies that NCS has not loaded the yang module.";
              }
              enum unknown  {
                tailf:code-name module-unknown;
                description
                  "that NCS has loaded the module but the revision
                   information was not available for comparison.";
              }
            }
          }
          leaf device-revision {
            type string;
            description "Live device reported revision for the module";
          }
          leaf ncs-revision {
            type string;
            description "NCS loaded YANG module revision";
          }
        }
      }
    }
  }

  grouping fetch-ssh-host-keys-grouping {
    tailf:action fetch-ssh-host-keys {
      tailf:info "Retrieve SSH host keys from all devices";
      description
        "Retrieve the SSH host keys from all devices, or all devices in the
         given device group, and store them in each device's ssh/host-key
         list. Successfully retrieved new or updated keys are always
         committed by the action.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          tailf:info "Only return result if key retrieval failed";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where key retrieval failed.";
        }
        leaf suppress-unchanged-result {
          tailf:info "Do not return result if keys are unchanged";
          type empty;
          description
            "If this optional parameter is included, no results are returned
             for devices which have the same keys as those already known.";
        }
        leaf suppress-fingerprints {
          tailf:info "Do not return key fingerprints";
          type empty;
          description
            "If this optional parameter is included, key fingerprints are
             not included in the results.";
        }
      }
      output {
        list fetch-result {
          description
            "This is a list of key retrieval results, each entry pertains
             to one device.";
          key device;
          leaf device {
            type leafref {
              path '/devices/device/name';
            }
            description
              "The name of the device.";
          }
          uses fetch-ssh-host-keys-result;
        }
      }
    }
  }

  grouping apply-template-grouping {
    tailf:action apply-template {
      description
        "Apply a template configuration. That is, take the named
         template and copy it here.

         This grouping is used inside managed devices, and in
         device groups.";
      tailf:info "Take a named template and copy it here";
      tailf:cli-configure-mode;
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf template-name {
          type leafref {
            path "/ncs:devices/ncs:template/ncs:name";
          }
          mandatory "true";
        }
        list variable {
          key name;
          leaf name {
            tailf:cli-completion-actionpoint "template-variable";
            type string {
              tailf:info
                "The name of the XPath variable as used in the template";
            }
            mandatory "true";
          }
          leaf value {
            type union {
              type string {
                tailf:info
                  "quoted;;some text enclosed in single quotes. This
                   is an XPath string.";
              }
              type string {
                tailf:info
                  "number;;some integer or float number. This is an XPath
                   number.";
              }
              type yang:xpath1.0 {
                tailf:info
                  "node set;;an XPath expression resulting in a node set";
              }
            }
            mandatory "true";
          }
        }
        leaf suppress-positive-result {
          tailf:info "Only return result if some error occurred";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where some error occurred.";
        }
        leaf accept-empty-capabilities {
          tailf:info "Apply template to devices with no capabilities known ";
          type empty;
          description
            "If this optional parameter is included, the template is applied to
             devices even if the capability of the device is unknown.";
        }
      }
      output {
        list apply-template-result {
          key device;
          leaf device {
            type leafref {
              path '/devices/device/name';
            }
          }
          leaf result {
            type enumeration {
              enum ok {
                tailf:code-name 'apply_template_ok';
                description
                  "The template was applied with success";
              }
              enum no-capabilities {
                tailf:code-name 'apply_template_no_capabilities';
                description
                  "One or more of the affected devices has no known
                   capabilities. This occures when NCS has not synced
                   from the device";
              }
              enum no-namespace {
                tailf:code-name 'apply_template_no_namespace';
                description
                  "One or more of the affected devices has no matching
                   namespace in the template.";
              }
            }
          }
          leaf info {
            type string;
            description
              "If present, contains additional information about the result.";
          }
        }
      }
    }
  }

  grouping location {
    container location {
      description "Physical location of devices in the group";
      leaf name {
        type string;
        description
          "An arbitrary name of the location.";
      }
      leaf latitude {
        type decimal64 {
          range "-90..90";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The latitude according to WGS-84, in decimal degrees.";
      }
      leaf longitude {
        type decimal64 {
          range "-180..180";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The longitude according to WGS-84, in decimal degrees.";
      }
      leaf altitude {
        type int32;
        units "meters";
        description
          "The altitude according to WGS-84, in meters.";
      }
    }
  }

  grouping queue-item-status {
    leaf status {
      tailf:display-groups "none details summary";
      type enumeration {
        enum waiting {
          description
            "The queue item is waiting to run.  This state means
             that there is some other item in the queue, ahead of this item.";
        }
        enum executing {
          description
            "The queue item is currently executing.

             Transient errors might be present. These errors occur when NCS
             fails to communicate with some of the devices. The errors are
             shown in the 'transient-errors' leaf-list.

             Retries will take place at intervals a specified in
             /devices/global-settings/commit-queue/
               connection-failure-reconnect-timer.

             Examples of transient errors are connection failures
             and that the changes are rejected due to the device
             being locked.

             Transient errors are potentially bad, since the queue might
             grow if new items are added, waiting for the same device.";
        }
        enum locked {
          description
            "This queue item is locked and will not be processed until it has
             been unlocked, see the action
             '/devices/commit-queue/queue-item/unlock'.

             A locked queue-item will block all subsequent queue-items
             which are using any device in the locked queue item.";
          tailf:code-name qi_locked;
        }
        enum blocked {
          description
            "The queue item is waiting in the queue, and some other
             queue item ahead of this item is in state 'locked' or 'executing'
             with transient errors.";
        }
        enum waiting-not-master {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master";
        }
        enum locked-not-master {
          description
             "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master";
        }
        enum blocked-not-master {
           description
             "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master";
        }
      }
      description
        "What is NCS currently doing with this queue item.
         If the status is idle, it means that the item is waiting
         for another queue item where one of the devices is
         not running, i.e., it's not possible to connect to that
         device.";
    }
  }

  grouping commit-queue-basic-options {
    leaf tag {
      type string;
      description
        "User defined opaque tag.
         The tag is present in all notifications and events
         sent referencing the specific queue item.";
    }
    choice operation-mode {
      leaf async {
        type empty;
        description
          "This flags means that if some device is non-operational or
           has data waiting in the commit-queue, the data in this
           transaction will be placed in the commit-queue.

           The operation returns successfully if the transaction has
           been successfully placed in the queue.  The leaf
           'commit-queue/id' is set to the queue identifier and the
           leaf 'commit-queue/status' is set to 'async' in the result.

           Note that this flag has no effect if
           /devices/commit-queue/enabled-by-default is 'true', since all
           commits go through the queue in this case.";
      }
      container sync {
        presence "Commit through the commit-queue and wait for completion";
        description
          "Commit the data synchronously to the commit-queue.

          The operation does not return until the transaction has been
          sent to all devices, or a timeout occurs.

          If no device is involved in the transaction, the operation
          returns 'ok' directly.";
        choice time-out-choice {
          default "infinity";
          leaf timeout {
            type uint32;
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               transaction to be committed. If the timer expires, the
               transaction is kept in the commit-queue, and the operation
               returns successfully. The leaf 'commit-queue/status'
               is set to 'timeout', and the leaf 'commit-queue/id' is
               set to the queue identifier in the result.

               If the timeout is not set, the operation waits until the
               transaction is committed.";
          }
          leaf infinity {
            description
              "Wait infinitely for the lock, this is the default";
            type empty;
          }
        }
      }
      default async;
    }
    leaf block-others {
      type empty;
      description
        "The resulting queue item will block subsequent queue items,
         which use any of the devices in this queue item, from
         being queued.";
    }
  }

  grouping commit-queue-options {
    uses commit-queue-basic-options {
      augment operation-mode {
        leaf bypass {
          type empty;
          description
            "This flag means that if
             /devices/commit-queue/enabled-by-default is 'true' the
             data in this transaction will bypass the commit-queue.
             The data will be written directly to the devices.";
        }
      }
    }
  }

  container devices {
    tailf:info "The managed devices and device communication settings";

    uses connect-grouping {
      augment "connect/input" {
        leaf-list device {
          tailf:info "Only connect to these devices.";
          type leafref {
            path '/devices/device/name';
          }
        }
      }
    }
    uses sync-grouping;
    uses sync-to-grouping {
      augment "sync-to/input" {
        leaf-list device {
          tailf:info "Only sync to these devices.";
          type leafref {
            path '/devices/device/name';
          }
        }
      }
    }
    uses sync-from-grouping {
      augment "sync-from/input" {
        leaf-list device {
          tailf:info "Only sync from these devices.";
          type leafref {
            path '/devices/device/name';
          }
        }
      }
    }
    uses disconnect-grouping {
      augment "disconnect/input" {
        leaf no-remote {
          tailf:display-when "/ncs:cluster/ncs:remote-node/ncs:name";
          type empty;
          description "Do not perform this action on remote cluster node";
          tailf:info "Do not perform this action on remote cluster node";
        }
      }
    }
    uses check-sync-grouping {
      augment "check-sync/input" {
        leaf-list device {
          tailf:info "Only check-sync these devices.";
          type leafref {
            path '/devices/device/name';
          }
        }
      }
    }
    uses check-yang-modules-grouping {
      augment "check-yang-modules/input" {
        leaf-list device {
          tailf:info "Specification of devices for which a module revision
                      compatibility check should be performed.";
          type leafref {
            path '/devices/device/name';
          }
        }
      }
    }
    uses fetch-ssh-host-keys-grouping {
      augment "fetch-ssh-host-keys/input" {
        leaf-list device {
          tailf:info "Only fetch host keys from these devices.";
          type leafref {
            path '/devices/device/name';
          }
        }
      }
    }
    tailf:action clear-trace {
      description
        "Clear all trace files for all active traces for all managed
         devices.";
      tailf:info "Clear all trace files";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf no-remote {
          tailf:display-when "/ncs:cluster/ncs:remote-node/ncs:name";
          type empty;
          description "Do not perform this action on remote cluster node";
          tailf:info "Do not perform this action on remote cluster node";
        }
      }
    }

    grouping timeouts {
      description
        "Timeouts used when communicating with a managed device.";

      leaf connect-timeout {
        tailf:info "Timeout in seconds for new connections";
        type uint32;
        units "seconds";
        description
          "The timeout in seconds for new connections to managed
           devices.";
      }
      leaf read-timeout {
        tailf:info "Timeout in seconds used when reading data";
        type uint32;
        units "seconds";
        description
          "The timeout in seconds used when reading data from a
           managed device.";
      }
      leaf write-timeout {
        tailf:info "Timeout in seconds used when writing data";
        type uint32;
        units "seconds";
        description
          "The timeout in seconds used when writing data to a
           managed device.";
      }
    }

    grouping device-profile-parameters {
      description
        "A set of parameters to use when communicating with a device.

         These parameters can be set on:

           o  global-settings
           o  device-profile
           o  device

         If a parameter is set on the device, its value is used.
         Otherwise, if the paramater is set in the device's
         device-profile, its value is used.  Otherwise, the global
         setting is used, if set.  Otherwise, the value used depends on
         the NED type.";

      uses timeouts;

      leaf trace {
        tailf:info "Trace the southbound communication to devices";
        type trace-flag;
        description
          "Controls southbound traffic trace to managed devices.";
      }

      container ned-settings {
        tailf:info "Control which device capabilities NCS uses";
        description
          "When communicating with a device, NCS adapts its behavior
           to the capabilities of the device.  When writing to the device,
           NCS uses the capabilities that give most control, and minimal
           risk of network inconsistencies.  The parameters in this
           container can be used to tweak NCS's behavior.  These parameters
           must be used with care.";

        leaf use-confirmed-commit {
          tailf:info "Control usage of confirmed commit";
          type boolean;
          description
            "Controls if NCS should use confirmed commit towards the
             device.  This setting has no effect if the device does
             not advertise support for confirmed-commit.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default uses confirmed commit if
             it is advertised.";

        }
        leaf use-validate {
          tailf:info "Control usage of validate";
          type boolean;
          description
            "Controls if NCS should use explicit validation towards the
             device.  This setting has no effect if the device does
             not advertise support for validate.

             It can be useful to disable validate in order to increase
             performance, since when validate is used, the device must
             validate the changes twice; at validate, and at commit.

             The advantage of using validate is that if the changes are
             sent to N devices, and validated on all of them, if one
             device fails the validation step, nothing has been committed
             to any device, and the transaction can easily be aborted.

             Without validate, NCS will commit on all N devices, and if
             one fails the commit due to a validation error, NCS has
             to undo the changes on the other devices.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default uses validate if
             it is advertised.";
        }
        leaf use-startup {
          tailf:info "Control usage of the startup datastore";
          type boolean;
          description
            "Controls if NCS should invoke the copy-running-to-startup
             operation towards the device.  This setting has no effect
             if the device does not advertise support for startup.

             It can be useful to disable this operaiotn in order to
             increase performance, in the case that this is an
             expensive operation on the device.  It should be noted
             that in this case, the device will not have all changes
             persistently stored.  This can be combined with a job
             that performs this operation periodically, e.g., once an
             hour.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default uses startup if
             it is advertised.";
        }
        leaf use-transaction-id {
          tailf:info "Control usage of fetching the transaction id";
          type boolean;
          description
            "For some devices, getting the transaction id can be a costly
             operation.  If it is disabled, NCS will not be able to
             detect situations where NCS and the device are out of
             sync.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default reads the transaction id,
             if it knows how to get it from the device.";
        }
        leaf use-private-candidate {
          tailf:info "Control usage of the private candidate";
          type boolean;
          description
            "If the device supports the concept of a private
             candidate, NCS can use it instead of the normal, shared
             candidate.

             This option can be useful if there are other management
             applications other than NCS configuring the devices, and
             these other applications also use private candidates.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default does not use a private
             candidate.  For NETCONF, this option currently has effect
             only for Juniper devices running Junos.";
        }
        // NEDs can augment NED-specific parameters here.
      }
    }

    container global-settings {
      tailf:info "Global settings for all managed devices.";
      description
        "Global settings for all managed devices.  Some of these
         settings can be overridden per managed device.";

      uses device-profile-parameters {
        refine connect-timeout {
          default 20;
        }
        refine read-timeout {
          default 20;
        }
        refine write-timeout {
          default 20;
        }
        refine trace {
          default false;
        }
      }

      container commit-retries {
        tailf:info "Retry commits on transient errors";
        description
          "Settings for how to retry commits if some device returns
           a transient error.  For example, if NCS fails to take a
           lock on a device, it can retry after a short time.";
        leaf attempts {
          type uint8;
          default 5;
          tailf:info "Number of retries before giving up";
          description
            "Number of attempts to retry the commit before giving up.

             Setting this to 0 means that the transaction fails
             immediately even on transient errors.";
        }
        leaf timeout {
          type uint32;
          units "seconds";
          default 3;
          tailf:info "Wait time in seconds between retries";
          description
            "Specifies the timeout in seconds between retries.";
        }
      }


      leaf trace-dir {
        tailf:info "The directory where trace files are stored";
        type string;
        default ".";
        description
          "Specifies the directory where southbound traffic trace log files
           to managed devices are stored.

           The trace files are called <type>-<device-name>.trace
           where <type> is one of 'netconf', 'snmp', or 'ned', depending on
           the type of the managed device.";
      }
      container commit-queue {
        leaf enabled-by-default {
          type boolean;
          default false;
          description
            "If this leaf is set, all commits will by default
             go through the commit-queue.";
        }
        leaf atomic {
          type boolean;
          default true;
          description
            "If this leaf is set to true, all new queue items in the
             commit queue will be run in an atomic fashion. This means
             that a queue item cannot process on the devices of another
             queue item unless the item is completed.";
        }
        leaf connection-failure-reconnect-timer {
          type uint32;
          units "seconds";
          default 30;
          description
            "When a queued item remains in the queue due to
             connection refused, shall NCS continously attempt
             to reconnect to the device in order to process the
             queued item.  Set to zero to disable functionality.";
        }
      }
      leaf out-of-sync-commit-behaviour {
        type enumeration {
          enum reject;
          enum accept;
        }
        default reject;
        description
          "Specifies the behaviour of a commit operation involving a
           device that is out of sync with NCS.  The default behaviour is
           to reject such commits.";
      }

      leaf report-multiple-errors {
        type boolean;
        default false;
        description
          "By default, when the NCS device manager commits data
           southbound and when there are errors, we only report
           the first error to the operator, this flag makes NCS
           report all errors reported by managed devices";
      }

    }

    container profiles {
      tailf:info "Device profile parameters";
      list profile {
        tailf:info "Parameters for a device profile";
        key name;
        leaf name {
          tailf:info "The name of the device profile";
          type string;
        }
        uses device-profile-parameters;
      }
    }

    container authgroups {
      tailf:info "Authentication for managed devices";
      description
        "Named authgroups are used to decide how to map a local NCS user to
         remote authentication credentials on a managed device.

         The list 'group' is used for NETCONF and CLI managed devices.

         The list 'snmp-group' is used for SNMP managed devices.";

      list group {
        tailf:info "Authentication settings for a group of devices";
        key name;

        description
          "When NCS connects to a managed device, it locates the
           authgroup configured for that device.  Then NCS looks up
           the local NCS user name in the 'umap' list.  If an entry is
           found, the credentials configured is used when
           authenticating to the managed device.

           If no entry is found in the 'umap' list, the credentials
           configured in 'default-map' are used.

           If no 'default-map' has been configured, and the local NCS
           user name is not found in the 'umap' list, the connection
           to the managed device fails.";

        grouping remote-user-remote-auth {
          description
            "Remote authentication credentials.";

          choice remote-user {
            mandatory true;
            leaf same-user {
              tailf:info "Use the local NCS user name as the remote user name";
              type empty;
              description
                "If this leaf exists, the name of the local NCS user is used
                 as the remote user name.";
            }
            leaf remote-name {
              tailf:info "Specify device user name";
              type string;
              description
                "Remote user name.";
            }
          }

          choice remote-auth {
            mandatory true;
            leaf same-pass {
              tailf:info "Use the local NCS password as the remote password";
              type empty;
              description
                "If this leaf exists, the password used by the local user
                 when logging in to NCS is used as the remote password.";
            }
            leaf remote-password {
              tailf:info "Specify the remote password";
              tailf:suppress-echo "true";
              type tailf:aes-cfb-128-encrypted-string;
              description
                "Remote password.";
            }
            case public-key {
              uses public-key-auth;
            }
          }
          leaf remote-secondary-password {
            tailf:info "Second password for configuration";
            tailf:suppress-echo "true";
            type tailf:aes-cfb-128-encrypted-string;
            description
              "Some CLI based devices require a second
               additional password to enter config mode";
          }
        }

        leaf name {
          tailf:info "The name of the authgroup";
          type string;
          description
            "The name of the authgroup.";
        }

        container default-map {
          presence "Map unknown users";
          description
            "If an authgroup has a default-map, it is used if a local
             NCS user is not found in the umap list.";
          tailf:info "Remote authentication parameters for users not in umap";
          uses remote-user-remote-auth;
        }

        list umap {
          key local-user;
          description
            "The umap is a list with the local NCS user name as key.
             It maps the local NCS user name to remote authentication
             credentials.";
          tailf:info "Map NCS users to remote authentication parameters";
          leaf local-user {
            type string;
            description
              "The local NCS user name.";
          }
          uses remote-user-remote-auth;
        }
      }
      list snmp-group {
        tailf:info "SNMP authentication groups";
        key name;

        description
          "When NCS connects to a managed device over SNMP, it locates
           the snmp-group configured for that device.  Then NCS looks
           up the local NCS user name in the 'umap' list.  If an entry
           is found, the credentials configured is used when
           authenticating to the managed device.

           If no entry is found in the 'umap' list, or credentials for
           the requested SNMP version has not been configured, the
           credentials configured in 'default-map' are used.

           If no 'default-map' has been configured, and the local NCS
           user name is not found in the 'umap' list, the connection
           to the managed device fails.";

        grouping key {
          choice key-type {
            leaf same-password {
              tailf:info "Use the local NCS password to create a localized key";
              type empty;
              description
                "Use the local NCS password as the password
                 used by NCS to create a localized key, as described
                 in RFC 3414.";
            }
            leaf remote-password {
              tailf:suppress-echo "true";
              type tailf:aes-cfb-128-encrypted-string;
              description
                "If this leaf is set, NCS uses its value to create
                 a localized key, as described in RFC 3414.";
              tailf:info "Explicit password";
            }
            leaf key {
              type tailf:hex-list;
              description
                "Non-localized key specified as a list of
                 colon-separated hexa-decimal octets.  NCS localizes
                 this key for a device before it is used, as described
                 in RFC 3414.";
              tailf:info "Explicit non-localized key";
            }
          }
        }

        grouping remote-snmp-credentials {
          description
            "Remote SNMP credentials.";

          choice community {
            leaf community-name {
              type string;
              description
                "A community name that can be represented as a
                 YANG string.";
              tailf:info "Community name as a string";
            }
            leaf community-binary-name {
              type binary;
              description
                "A community name represented as a binary value.";
              tailf:info "Community name as a binary value";
            }
          }

          container usm {
            presence "enables usm";
            tailf:info "USM parameters";
            choice remote-user {
              mandatory true;
              leaf same-user {
                type empty;
                description
                  "Use the local NCS user name as the remote USM user name.";
                tailf:info "Use current user's local name as USM user name";
              }
              leaf remote-name {
                type string {
                  length "1..32";
                }
                description
                  "Remote USM user name.";
                reference "SNMP-USER-BASED-SM-MIB.usmUserName";
                tailf:info "Explicit USM user name";
              }
            }
            leaf security-level {
              type snmp-security-level;
              mandatory true;
              must ". = 'no-auth-no-priv' or ../auth" {
                error-message
                  "when security-level indicates authentication,"
                + " the auth parameters must be set.";
                tailf:dependency "../auth";
              }
              must "(. = 'auth-priv' and ../priv)"
                 + " or (. != 'auth-priv')" {
                error-message
                  "when security-level indicates privacy,"
                + " the priv parameters must be set.";
                tailf:dependency "../priv";
              }
              tailf:info "SNMP security level";
            }
            container auth {
              presence "enables authentication";
              tailf:info "SNMP authentication parameters";
              choice protocol {
                mandatory true;
                reference "SNMP-USER-BASED-SM-MIB.usmUserAuthProtocol";
                container md5 {
                  uses key;
                  reference "SNMP-USER-BASED-SM-MIB.usmHMACMD5AuthProtocol";
                }
                container sha {
                  uses key;
                  reference "SNMP-USER-BASED-SM-MIB.usmHMACSHAAuthProtocol";
                }
              }
            }
            container priv {
              presence "enables privacy";
              tailf:info "SNMP privacy parameters";
              must "../auth" {
                error-message
                  "when privacy is used, authentication must also be used";
              }
              choice protocol {
                mandatory true;
                reference "SNMP-USER-BASED-SM-MIB.usmUserPrivProtocol";
                container des {
                  uses key;
                  reference "SNMP-USER-BASED-SM-MIB.usmDESPrivProtocol";
                }
                container aes {
                  uses key;
                  reference "SNMP-USM-AES-MIB.usmAesCfb128Protocol";
                }
              }
            }
          }
        }

        leaf name {
          tailf:info "The name of the snmp authgroup";
          type string;
          description
            "The name of the snmp authgroup.";
        }
        container default-map {
          presence "Map unknown users";
          description
            "If an snmp auth group has a default-map, it is used if a
             local NCS user is not found in the umap list.";
          tailf:info "Remote authentication parameters for users not in umap";
          uses remote-snmp-credentials;
        }
        list umap {
          key local-user;
          description
            "The umap is a list with the local NCS user name as key.
             It maps the local NCS user name to remote authentication
             credentials.";
          tailf:info "Map NCS users to remote authentication parameters";
          leaf local-user {
            type string;
            description
              "The local NCS user name.";
          }
          uses remote-snmp-credentials;
        }
      }
    }

    list template {
      tailf:info "Named configuration templates for devices";
      key name;
      description
        "This list is used to define named template configurations that
         can be used to either instantiate the configuration for new
         devices, or to apply snippets of configurations to existing
         devices.

         A template is applied by invoking the 'apply-template' action
         in a device-group or in a device.

         When template is applied, the nodes in the template are by
         default merged with the nodes in the target device.  This
         behaviour can be changed by using tags:

         If a list or container node in the template contains a tag
         with the value 'replace', the template application will
         change from merge to replace for this node.

         Otherwise, if a list or container node in the template
         contains a tag with the value 'nocreate', the template
         application will never create this node or anything below it;
         it will only modify existing containers and list entries.

         Otherwise, if a node in the template contains a tag with the
         value 'delete', the template application will delete this
         node from the device, if it exists.";
      leaf name {
        type string;
        description
          "The name of a specific template configuration.";
      }
      container config {
        tailf:cli-add-mode;
        tailf:cli-expose-ns-prefix;
        description
          "This container is augmented with data models from the devices.";
      }
    }

    list device-group {
      tailf:info "Groups of devices";
      key name;
      leaf name {
        type string;
      }
      description
        "A named group of devices, some actions can be
         applied to an entire  group of devices, for example
         apply-template, and the sync actions.";
      tailf:validate ncs {
        tailf:internal;
        tailf:call-once true;
        tailf:dependency "device-group";
      }

      uses location {
        description
          "Location of the device group.  These nodes are expected to be
           configured by the operator, typically by using a map application
           in e.g., the Web UI.";
      }

      leaf-list device-name {
        tailf:info "Device within group";
        type leafref {
          path "/devices/device/name";
        }
      }
      leaf-list device-group {
        tailf:info "Group within group";
        type leafref {
          path "/devices/device-group/name";
        }
        description
          "A list of device groups contained in this device group.

           Recursive definitions are not valid.";
      }
      leaf-list member {
        tailf:info "Flattened list of all members";
        type leafref {
          path "/devices/device/name";
        }
        config false;
        description
          "The current members of the device-group.  This is a flat list
           of all the devices in the group.";
        tailf:callpoint ncs {
          tailf:internal;
        }
      }
      uses connect-grouping ;
      uses sync-grouping;
      uses sync-to-grouping;
      uses sync-from-grouping;
      uses check-sync-grouping;
      uses check-yang-modules-grouping;
      uses fetch-ssh-host-keys-grouping;
      uses apply-template-grouping;
    }

    list mib-group {
      tailf:info "A list of named groups of MIBs";
      key name;
      description
        "A list of named groups of MIBs.

         This list is used so that SNMP devices can refer to collections
         of MIBs, instead of having to refer to individual MIBs.

         For example, an operator can configure one MIB group per
         device model.";
      tailf:validate ncs {
        tailf:internal;
        tailf:call-once true;
        tailf:dependency "mib-group";
      }
      leaf name {
        type string;
        description
          "An arbitrary name of the MIB group.";
      }
      leaf-list mib-module {
        tailf:info "MIB module names or name prefixes";
        type string;
        description
          "A list of MIB module names or MIB module name prefixes in
           this MIB group.

           The string is either exactly matches a MIB module, e.g.,
           'SNMPv2-MIB', or a prefix followed by a wildcard, e.g.,
           'SNMP-*'.  Such a prefix matches all MIB modules with names
           starting by 'SNMP-'.";
        tailf:non-strict-leafref {
          path "/devices/device-module/mib-module";
        }
      }
      leaf-list mib-group {
        tailf:info "A list of MIB groups contained in this MIB group";
        type leafref {
          path "/devices/mib-group/name";
        }
        description
          "A list of MIB groups contained in this MIB group.

           Recursive definitions are not valid.";
      }
    }

    list device-module {
      tailf:info "List the devices and supported modules";
      key name;
      config false;
      description
        "List of all modules on all managed devices.";
      tailf:callpoint ncs {
        tailf:internal;
      }

      leaf name {
        tailf:info "The module name";
        type string;
        description
          "The module name.";
      }
      leaf-list revision {
        tailf:info "The module revision";
        type string;
        description
          "Lists the revisions of this module.";
      }
      leaf uri {
        tailf:info "The XML namespace uri for the module";
        type string;
        description
          "The XML namespace uri for the module.";
      }
      leaf-list devices {
        tailf:info "The names of the devices that support this module";
        type string;
        description
           "The names of the devices that support this module.";
      }
      leaf mib-module {
        type string;
        tailf:hidden full;
        description
          "Used internally.";
      }
    }

    list device {
      tailf:info "The list of managed devices";
      key name;

      description
        "This list contains all devices managed by NCS.";

      leaf name {
        tailf:info "A string uniquely identifying the managed device";
        tailf:cli-allow-range;
        type string;
        description
          "A string uniquely identifying the managed device.";
      }

      must "remote-node or address" {
        error-message "Either address or remote-node must be configured.";
        tailf:dependency "ncs:address";
        tailf:dependency "ncs:remote-node";
      }

      leaf address {
        tailf:info "IP address or host name for the management interface";
        type inet:host;
        description
          "IP address or host name for the management interface on the device.";
      }
      leaf port {
        tailf:info "Port for the management interface";
        type inet:port-number;
        description
          "Port for the management interface on the device.  If this leaf is
           not configured, NCS will use a default value based on the type
           of device.  For example, a NETCONF device uses port 830, a
           CLI device over SSH uses port 22, and a SNMP device uses port 161.";
      }
      leaf remote-node {
        tailf:info "Name of remote node which connects to device";
        type leafref {
          path '/ncs:cluster/ncs:remote-node/ncs:name';
        }
        description
          "Setting remote-node indicates that this device is managed by
           another cluster node. When set, all other device settings are
           read and write through to the remote node, i.e. nothing is
           locally stored about this device.";
      }
      uses ssh-connection-config;

      leaf description {
        tailf:info "Free form textual description";
        type string;
        description
          "Free form text describing the device.";
      }
      uses location {
        description
          "Location of the device.  These nodes are expected to be
           configured by the operator, typically by using a map application
           in e.g., the Web UI.";
      }

      grouping ne-type {

        leaf authgroup {
          tailf:info "Authentication credentials for the device";
          type leafref {
            path '/devices/authgroups/group/name';
          }
          description
            "The authentication credentials used when connecting
             to this managed device.

             This leaf must be set for NETCONF and CLI devices, and
             may be used by generic NEDs, if applicable.";
        }

        container device-type {
          tailf:info "Management protocol for the device";
          choice ne-type {
            case netconf {
              leaf netconf {
                tailf:info "Use NETCONF to talk to the device";
                type empty;
                must "../../authgroup" {
                  error-message
                    "A NETCONF device must have a authgroup.";
                  tailf:dependency "../../authgroup";
                }
              }
            }
            case generic {
              container generic {
                tailf:info "Use a generic NED to talk to the device";
                presence "use a generic ned to communicate with the device";
                leaf ned-id {
                  tailf:info "The NED Identity";
                  type identityref {
                    base ned:generic-ned-id;
                  }
                  mandatory true;
                }
              }
            }
            case cli {
              container cli {
                tailf:info "Use CLI to communicate with the device";
                presence "use CLI to communicate with the device";
                must "../../authgroup" {
                  error-message
                    "A CLI device must have a authgroup.";
                  tailf:dependency "../../authgroup";
                }
                leaf ned-id {
                  tailf:info "The NED Identity";
                  type identityref {
                    base ned:cli-ned-id;
                  }
                  mandatory true;
                }
                leaf protocol {
                  tailf:info "The CLI protocol";
                  type enumeration {
                    enum telnet;
                    enum ssh;
                  }
                  default ssh;
                }
              }
            }
            case snmp {
              container snmp {
                presence "use SNMP to communicate with the device";
                leaf version {
                  type snmp-version;
                  mandatory true;
                  tailf:info "SNMP version to use";
                }
                leaf context-name {
                  when "../version = 'v3'";
                  type string;
                  default "";
                  description
                    "The SNMP context name to use when communicating
                     with the device.  If an SNMP engine supports multiple
                     contexts, each context must be handled as a separate
                     managed-device in NCS.";
                  reference
                    "RFC 3411: Architecture for SNMP Management Frameworks";
                  tailf:info "SNMP context to use";
                }
                leaf snmp-authgroup {
                  type leafref {
                    path '/devices/authgroups/snmp-group/name';
                  }
                  mandatory true;
                  tailf:info "Name of an SNMP authgroup";
                }
                leaf retries {
                  type uint8;
                  default 3;
                  description
                    "Specifies the number of retries to be used when sending
                     a request.";
                  tailf:info "Number of times a request is resent";
                }
                leaf timeout {
                  type uint32;
                  units "seconds";
                  default 1;
                  description
                    "Specifies the timeout in seconds between retries.";
                  tailf:info "Wait time in seconds between retries";
                }
                leaf-list mib-group {
                  tailf:info "A list of MIB groups implemented by the device";
                  type leafref {
                    path '/devices/mib-group/name';
                  }
                  description
                    "A list of MIB groups implemented by the device.

                     In SNMP, there is no generic, automatic way to
                     figure out which MIBs an agent implements.  Thus,
                     this list can be used to inform NCS which MIBs the
                     device implements.

                     If this list is empty, NCS assumes that the device
                     implements all MIBs known to NCS.

                     The MIBs NCS thinks the device implements are
                     listed in /devices/module.  These
                     modules are used by NCS to control what data can
                     be configured under /devices/device/config,
                     and what data is shown in
                     /devices/device/live-status.";
                }
              }
            }
          }
        }
      }

      uses ne-type {
        refine device-type {
          must "../remote-node or netconf or generic or cli or snmp" {
            // Same error message as when the choice is mandatory
            error-message "must configure one of: snmp, cli, generic, netconf";
            tailf:dependency "../ncs:remote-node";
            tailf:dependency "ncs:netconf";
            tailf:dependency "ncs:generic";
            tailf:dependency "ncs:cli";
            tailf:dependency "ncs:snmp";
          }
        }
      }

      leaf device-profile {
        type leafref {
          path "/devices/profiles/profile/name";
        }
      }

      uses device-profile-parameters;

      list live-status-protocol {
        tailf:info "Additional protocols for the live-tree (read-only)";
        key name;
        description
          "It is possible to have additional NEDs speaking
           southbound to the managed device for the device's
           'live-status' tree.

           All configuration data must be handled by one NED, but
           multiple NEDs can be used for the 'live-status' tree.

           For example a CLI NED can be used for 'show routes'
           and the SNMP NED for some additional MIBs";
        leaf name {
          type string;
        }

        leaf address {
          tailf:info "IP Address for the management interface";
          type inet:host;
          description
            "IP address or host name for the management interface on
             the device. If omitted the same address as configured for
             this device will be used.";
        }

        leaf port {
          tailf:info "Port for the management interface";
          type inet:port-number;
          description
            "Port for the management interface on the device.  If this leaf
             is not configured, NCS will use a default value based on
             the type of device.  For example, a NETCONF device uses
             port 830, a CLI device over SSH uses port 22, and a SNMP
             device uses port 161.";
        }

        container ssh {
          presence "protocol-specific ssh host keys";
          tailf:info "SSH host key configuration";
          tailf:code-name ssh_container;
          description
            "SSH host keys for this protocol. If not present, the host keys
             configured for this device will be used.";
          uses ssh-host-keys;
        }

        uses ne-type {
          refine device-type {
            must "../../remote-node or netconf or generic or cli or snmp" {
              // Same error message as when the choice is mandatory
              error-message
                "must configure one of: snmp, cli, generic, netconf";
              tailf:dependency "../../ncs:remote-node";
              tailf:dependency "ncs:netconf";
              tailf:dependency "ncs:generic";
              tailf:dependency "ncs:cli";
              tailf:dependency "ncs:snmp";
            }
          }
        }

        container state {
          tailf:info "Operational State for the live protocol";
          config false;
          tailf:cdb-oper {
            tailf:persistent true;
          }
          uses oper-state;
        }

        list capability {
          tailf:info "List of capabillities supported by the device";
          key uri;
          config false;
          description
            "This is a list of the capabilities supported by the device.
             when additional NEDs have been configured in the live tree.
             This list is thus the result of those extra stats NEDs.
             This list is populated the first time NCS connects to the
             device.  Not dependant on local-user.";
          tailf:cdb-oper {
            tailf:persistent true;
          }

          leaf uri {
            tailf:info "Capability URI";
            type string;
          }
          leaf revision {
            tailf:info "Capability revision";
            type string;
          }
          leaf module {
            tailf:info "Capability module";
            type string;
          }
          leaf-list feature {
            tailf:info "Capability features";
            type string;
          }
          leaf-list deviation {
            tailf:info "Capability deviations";
            type string;
          }
        }
      }

      container commit-queue {
        leaf queue-length {
          type int32;
          config false;
          tailf:callpoint ncs {
            tailf:internal;
          }
        }
        list waiting-for {
          config false;
          tailf:callpoint ncs {
            tailf:internal;
          }
          choice type {
            leaf device {
              type leafref {
                path "/devices/device/name";
              }
            }
            leaf cluster-node {
              type leafref {
                path "/cluster/remote-node/name";
              }
            }
          }
        }
      }

      container state {
        tailf:info "Show states for the device";
        uses oper-state;

        leaf transaction-mode {
          type enumeration {
            enum start-trans-running {
              description
                "NETCONF devices that support the Tail-f capability
                 http://tail-f.com/ns/netconf/transactions/1.0 and
                 :writable-running.";
            }
            enum lock-reset-candidate {
              description
                "NETCONF devices that support :candidate and
                 :writable-running.";
            }
            enum lock-candidate {
              description
                "NETCONF devices that support :candidate but not
                 :writable-running.";
            }
            enum startup {
              description
                "NETCONF devices with :writable-running and :startup.";
            }
            enum running-only {
              description
                "NETCONF devices with :writable-running only.";
            }
            enum private-candidate {
              description
                "NETCONF devices that support the concept of a private
                 candidate.  There is no standard capability for this,
                 but some devices support it.";
            }
            enum ned {
              tailf:code-name transmode-ned;
              description
                "The transaction is controlled by a Network Equipment
                 Driver.  The exact transaction mode depends on the type
                 of the NED.";
            }

          }
          config false;
          description
            "Describes which transaction mode NCS has choosen for
             NETCONF traffic towards the device.";
          tailf:cdb-oper {
            tailf:persistent true;
          }
        }

        leaf last-transaction-id {
          type string;
          config false;
          description
            "If the device supports the tailf-netconf-monitoring module,
             NCS keeps track of this string when reconfiguring a
             device, making it possible to cheeply check if a device
             has been reconfigured out of band.

             This value gets intialized when NCS syncs towards a device,
             and is then subsequently updated with each commit.";

          tailf:cdb-oper {
            tailf:persistent true;
          }
        }
        leaf admin-state {
          tailf:info "Controls configuration and southbound communication";
          type admin-state;
          default southbound-locked;
        }
        leaf admin-state-description {
          type string;
          description
            "Reason for the admin state.";
        }
      }
      container source {
        tailf:info "How the device was added to NCS";
        leaf added-by-user {
          type string;
        }
        leaf context {
          type string;
        }
        leaf when {
          type yang:date-and-time;
        }
        leaf from-ip {
          type inet:ip-address;
        }
        leaf source {
          type string;
          reference "TMF518 NRB Network Resource Basics";
        }
      }


      list capability {
        tailf:info "A list of capabilities supported by the device";
        key uri;
        config false;
        description
          "This is a list of the capabilities supported by the device.

           This list is populated the first time NCS connects to the
           device.  Not dependant on local-user.";
        tailf:cdb-oper {
          tailf:persistent true;
        }

        leaf uri {
          type string;
        }
        leaf revision {
          type string;
        }
        leaf module {
          type string;
        }
        leaf-list feature {
          type string;
        }
        leaf-list deviation {
          type string;
        }
      }

      list module {
        key name;
        config false;
        description
          "This is a list of the YANG modules supported by the device.

           This list is populated the first time NCS connects to the
           device.";
        tailf:cdb-oper {
          tailf:persistent true;
        }

        leaf name {
          type string;
        }
        leaf revision {
          type string;
        }
        leaf-list features {
          type string;
        }
        leaf-list deviations {
          type string;
        }
      }

      container platform {
        config false;
        description
          "Contains vendor-specific information for
           identifying the system platform.

           NEDs MAY augment this container with more device-specific
           nodes.";

        leaf name {
          type string;
          description
            "The name of the system platform, for example,
             'ios', 'ios-xr', or 'open-wrt'.";
        }
        leaf version {
          type string;
          description
            "The current version of the system platform.  The format
             of this string is vendor-specific.";
        }
        leaf model {
          type string;
          description
            "The name of the product model.  For example: if the device
             comes in different types of hardware it may refer to the
             hardware model or if the NED supports several different
             platforms the model may refer to a product family.";
        }
      }

      uses apply-template-grouping;

      tailf:action instantiate-from-other-device {
        description
          "Instantiate the configuration for the device as a copy of the
           configuration of some other already working device.";
        tailf:info "Instantiate the config for the device from existing device";
        tailf:cli-configure-mode;
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf device-name {
            type leafref {
              path "/devices/device/name";
            }
          }
        }
      }

      tailf:action compare-config {
        description
          "Retrieve the config from the device and compare
           to the NCS locally stored copy.";
        tailf:info "Compare the actual device config with the NCS copy";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf outformat {
            type outformat2;
          }
        }
        output {
          leaf diff {
            type string;
          }
        }
      }

      tailf:action sync {
        status deprecated;
        description
          "Synchronize the configs by either pulling from or pushing
           to the device.

           This action is deprecated.  Use 'sync-to' or 'sync-from'
           instead.";
        tailf:info "DEPRECATED - use sync-to or sync-from instead";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf direction {
            type enumeration {
              enum to-device;
              enum from-device;
            }
            mandatory true;
          }
          leaf mode {
            when '../direction = "to-device"';
            type enumeration {
              enum replace;
            }
          }
        }
        output {
          uses sync-result;
        }
      }

      tailf:action sync-from {
        description
          "Synchronize the configuration by pulling from the device.";
        tailf:info "Synchronize the config by pulling from the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
        }
        output {
          uses sync-result;
        }
      }

      tailf:action sync-to {
        description
          "Synchronize the configuration by pushing to the device.

           By default, NCS pushes a minimal diff to the device.  The
           diff is calculated by reading the configuration from the
           devices and comparing with the configuration in NCS.

           For a NETCONF device, NCS can optionally replace the
           configuration on the device by sending its own
           configuration without calculating the diff.  Note that NCS
           will send an <edit-config> with the 'replace' option in
           this case.  This means that configuration subtrees that NCS
           does not know about are not replaced.

           If the dry-run option is used, NCS will just report what it
           will do do instead of doing it.";
        tailf:info "Synchronize the config by pushing to the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf mode {
            type enumeration {
              enum replace;
            }
            description
              "For a NETCONF device, replace the device configurations
               with the NCS configurations, instead of sending the diff.

               Cannot be used with a non-NETCONF device.";
          }
          leaf dry-run {
            type empty;
            description
              "Report what would be done towards the device, without
               actually doing anything.";
          }
        }
        output {
          uses sync-to-result;
        }
      }

      tailf:action check-sync {
        description
          "Perform a cheap sync check, checking if NCS's
           configuration is in sync with this device's configuration,
           using device-specific mechanisms.  If the device
           doesn't support cheap sync check, 'check-sync' returns
           'unsupported'.";
        tailf:info "Check if the NCS config is in sync with the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        output {
          uses check-sync-result;
        }
      }

      tailf:action check-yang-modules {
        description
          "Check if the device YANG modules loaded by NCS
           have revisions that are compatible with the ones reported
           by the device.";
        tailf:info "Check if NCS and the device have compatible YANG modules";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf verbose {
            type empty;
            description
              "Use this to show additional compatibility info.";
          }
        }
        output {
          uses check-yang-modules-result;
        }
      }

      tailf:action connect {
        description
          "Set up a session to the device.";
        tailf:info "Connect to the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf override-southbound-locked {
            type empty;
            description
              "When a device is southbound locked, all southbound
               communication is turned off. This flag overrides the
               southbound lock for connection attempts.  Thus, this
               is a way to update the capabilities including revision
               information for a managed device although the device
               is southbound locked.";
          }
        }
        output {
          uses connect-result;
        }
      }

      uses disconnect-grouping {
        refine disconnect {
          tailf:info "Close all sessions to the device";
        }
      }

      tailf:action ping {
        description
          "ICMP ping the device.";
        tailf:info "ICMP ping the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        output {
          leaf result {
            type string;
          }
        }
      }

      tailf:action delete-config {
        description
          "Delete the device configuration in NCS without executing
           the corresponding delete on the managed device.";
        tailf:info "Delete the config in NCS without deleting it in the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
      }

      container config {
        tailf:cli-add-mode;
        tailf:cli-expose-ns-prefix;
        tailf:info "NCS copy of the device configuration";
        description
          "This container is augmented with configuration data nodes
           from the device's data models.

           This is where NCS's copy of the device configuration is stored.";
      }

      container live-status {
        tailf:info "Status data fetched from the device";
        description
          "This container is augmented with status data nodes
           from the device's data models.


           All data models from the device are augmented as config
           false data.  Thus this container contains both the status
           and running configuration on the device.  Whenever data in
           this tree is accessed, NCS will retrieve data from the
           device in real time.

           The purpose is to expose status data from the managed devices in
           the NCS data tree.";
        tailf:callpoint ncs_live {
          tailf:internal;
        }
        config false;
      }

      container rpc {
        tailf:info "RPCs from the device";
        description
          "This container is augmented with top-level rpcs
           from the device's data models.

           The rpcs are augments as tailf:actions.  This makes it possible
           to invoke rpcs on the devices through the NCS data model.";
      }

      container netconf-notifications {
        tailf:info "NETCONF notifications from the device";
        description
          "NETCONF notification support";
        reference "RFC5277 - NETCONF Event Notifications";

        list subscription {
          tailf:info "List of subscriptions";
          key "name";
          description
            "A list of our NETCONF notification subscriptions
             for this managed device.";

          leaf name {
            type string;
            description
              "Each subscription must have a unique name.";
          }

          // This really should be a leafref to ../stream/name but since
          // it's a truly bad idea to have leafrefs to stats data, it's
          // just a string

          leaf stream {
            tailf:info "The notification stream name";
            type string;
            mandatory true;
            description
              "The name of the NETCONF notification stream
               this subscription refers to.";
          }

          choice filter {
            description
              "Optional element, if not set, no filters are applied.";
            case xpath {
              leaf xpath {
                tailf:info "XPath filter for the notifications";
                type yang:xpath1.0;
              }
            }
            case subtree {
              leaf subtree {
                tailf:info "Subtree filter for the notifications";
                type string;
              }
            }
          }

          // add connection interval, interval check if down etc etc

          leaf local-user {
            type string;
            mandatory true;
            description
              "The local user is used when setting up a device
               connection.";
          }

          leaf utilize-replay {
            tailf:info "Use replay when connecting to the device";
            type boolean;
            default true;
            description
              "If the device supports replay, should NCS
               attempt to use that when connecting to the
               device.";

          }

          leaf reconnect-interval {
            tailf:info "Interval for re-establishing the subscription";
            type uint32;
            units "seconds";
            default 60;
            description
              "If the device is non operational, with which
               interval (in seconds) shall NCS attempt to re-establish
               the subscription.";
          }

          leaf status {
            type enumeration {
              enum running {
                description
                  "The subscription is established and NCS should
                   be receiving NETCONF notifications.";
              }
              enum connecting {
                description
                  "Attempting to establish the subscription.";
              }
              enum failed {
                tailf:code-name 'notif-failed';
                description
                  "The subscription has failed.  Unless the failure is
                   in the connection establishing, i.e., connect()
                   failed, there will be no automatic re-connect.";
              }
            }
            config false;
            description
              "Is this subscription currently running.";
            tailf:callpoint ncs {
              tailf:internal;
            }
          }

          leaf failure-reason {
            type enumeration {
              enum connection-refused {
                description
                  "Failed to connect to the device.";
              }
              enum connection-timeout {
                description
                  "Timeout when connecting to the device.";
              }
              enum session {
                description
                  "Failed to establish NETCONF session.";
              }
              enum subscribe {
                description
                  "The device rejected our subscription attempt.";
              }
              enum xml {
                tailf:code-name 'notif-xml';
                description
                  "NCS received XML that could not be parsed.";
              }
              enum internal {
                description
                  "Internal NCS error.";
              }
              enum disconnected {
                description
                  "Manually disconnected.";
              }
              enum closed {
                tailf:code-name 'notif-closed';
                description
                  "Server closed its end.";
              }
              enum not-master {
                description
                  "NCS is in slave or none mode, the notification is
                   disabled until NCS is master.";
              }
              enum locked {
                tailf:code-name 'notif-locked';
                description
                  "No subscriptions allowed towards devices that are
                   locked or southbound locked.";
              }
            }
            config false;
            description
              "If there is a problem with this subscription
               this leaf indicates what the problem is.";
            tailf:callpoint ncs {
              tailf:internal;
            }
          }

          leaf error-info {
            type string;
            config false;
            description
              "Contains additional information, if available, when the
               status is not equal to 'running'.";
            tailf:callpoint ncs {
              tailf:internal;
            }
          }


          tailf:action reconnect {
            tailf:info "Attempt to reconnect this subscription";
            description
              "Attempt to reconnect this subscription.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
          }

          tailf:action disconnect {
            tailf:info "Disconnect this subscription if connected";
            description
              "Disconnect this subscription if connected.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
          }

          tailf:action replay {
            tailf:info "Replay (missed) notifications from the device";
            description
              "Ask the device to replay all notifications that have a
               later timestamp than the oldest notification stored in
               NCS for this subscription, optionally if a timestamp is
               given, all notifications newer than the provided
               timestamp are requested.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
            input  {
              leaf from-date-time {
                type yang:date-and-time;
              }
            }
          }
        }
        list stream {
          key name;
          config false;

          description
            "A list of the NETCONF notification streams
             provided by the device. NCS reads this list in
             realtime.";

          tailf:callpoint ncs {
            tailf:internal;
          }
          leaf name {
            type string;
            description
              "The name of the the stream.";
          }
          leaf description {
            type string;
            description
              "A textual desription of the stream.";
          }
          leaf replay-support {
            type boolean;
            description
              "An indication of whether or not event replay
               is available on this stream.";
          }
          leaf replay-log-creation-time {
            type yang:date-and-time;
            description
              "The timestamp of the creation of the log used to support
               the replay function on this stream.  Note that this might
               be earlier then the earliest available notification in the
               log.  This object is updated if the log resets for some
               reason.";
          }
          leaf replay-log-aged-time {
            type yang:date-and-time;
            description
              "The timestamp of the last notification aged out of the log.";
          }
        }

        list notification-name {
          key name;
          config false;

          description
            "List of all names of notifications defined by this device.";

          tailf:callpoint ncs {
            tailf:internal;
          }
          leaf name {
            type string;
            description
              "The XML tag of the notification name.";
          }
          leaf uri {
            type string;
            description
              "The XML namespace uri for this notification.";
          }
        }

        container received-notifications {

          leaf max-size {
            type int32;
            default 200;
            description
              "Max size of the list of received notifications.
               When the maximum size is reached, the oldest
               received notification is purged.";
          }

          leaf clear-time {
            type yang:date-and-time;
            config false;
            tailf:cdb-oper {
              tailf:persistent true;
            }
            description
              "When were notifications last cleared.";
          }

          tailf:action clear {
            description
              "Clear all received notifications.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
          }


          list notification {
            key "event-time sequence-no";

            config false;
            description
              "A list of received NETCONF notifications from
               the device. The list is a circular list, with a
               maximum size. When a new notification is added to the
               list, the oldest entry is purged.";

            tailf:cdb-oper {
              tailf:persistent true;
            }

            leaf event-time {
              type yang:date-and-time;
              description
                "The time the event was generated at the device.";
            }
            leaf sequence-no {
               type int32;
            }
            leaf user {
              type string;
              description
                "User name of the user that created the subscription
                 that made this notification end up here.";
            }
            leaf subscription {
              type string;
              description
                "The name of the subscription that made this
                 notification end up here.";
            }
            leaf stream {
              type string;
              description
                "The name of the stream this notification belongs to.";
            }
            leaf received-time {
              type yang:date-and-time;
              description
                "The time the event was received at NCS.";
            }

            container data {
              description
                "This container is automatically augmented with notifications
                 from the managed device. Whenever a device module
                 that contains NETCONF notifications is compiled, the device
                 specific notifications end up here, as a container
                 with the same name as the device notification.";
            }
          }
        }
      }

      leaf-list service-list {
        tailf:info "Show services that use this device";
        type string;
        config false;
        description
          "A list of services that use this device.";
        tailf:callpoint ncs {
          tailf:internal;
        }
      }
    }
    container commit-queue {
      tailf:info "List of queued commits";
      tailf:display-groups "none details summary";
      config false;
      tailf:cdb-oper {
        tailf:persistent true;
      }

      tailf:action clear {
        description
          "Delete all items in the queue.  This makes all queued
           devices in the commit-queue out of sync.";
        tailf:info "Clear the entire queue";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        output {
          leaf num-deleted-queue-items {
            type uint32;
          }
        }
      }
      tailf:action prune {
        description
          "Prune the portions of all queue items that contain
           any of the devices in the input. This is a useful action to
           run when a device has been taken off-line. When we do that
           we want to ensure that no queue item remain for that
           device, possibly blocking the queue.";
        tailf:info "Prune portions of all queue items in the queue";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf-list device {
            type leafref {
              path "/devices/device/name";
            }
          }
        }
        output {
          leaf num-affected-queue-items {
            type uint32;
            description
              "Queue items that had a portion removed.";
          }
          leaf num-deleted-queue-items {
            type uint32;
            description
              "Queue items that were finally deleted because
               nothing remained.";
          }
        }
      }
      tailf:action set-atomic-behaviour {
        description
          "Set the atomic behaviour of all queue items. If this is set to
           false, these queue items will process on other non-atomic
           queue items with completed devices.";
        tailf:info "Set the atomic behaviour of all queue items";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf atomic {
            type boolean;
            mandatory true;
          }
        }
        output {
          leaf num-affected-queue-items {
            type uint32;
            description
              "Queue items that have changed atomic behaviour.";
          }
        }
      }
      tailf:action wait-until-empty {
        description
          "Wait at most 'timeout' seconds for the commit-queue
           to become empty.  Useful action when we script towards
           NCS, usually combined with locking NCS exclusively.

           If no parameter is given, the action waits indefinitely.";
        tailf:info "Wait for the commit-queue to become empty";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          choice timeout-choice {
            default infinity;
            leaf timeout {
              type uint32;
              units "seconds";
            }
            leaf infinity {
              type empty;
            }
          }
        }
        output {
          leaf result {
            type enumeration {
              enum empty {
                description
                  "Returned if the queue is empty.";
              }
              enum timeout {
                description
                  "Returned if the timer expired before the queue became
                   empty.";
                tailf:code-name wait_timeout;
              }
            }
          }
        }
      }
      tailf:action add-lock {
        description
          "Add a locked queue item to the commit-queue.";

        tailf:info "Add a lock for devices in the queue";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          uses commit-queue-basic-options {
            refine "operation-mode/async/async" {
              description
                "Add the lock asynchronously to the commit queue";
            }
            refine "operation-mode/sync/sync" {
              description
                "Add the lock synchronously. Block until the lock
                 has been successfully placed in the commit queue and
                 no other queue items, using any of the devices, are
                 ahead in the queue.";
            }
            refine "operation-mode/sync/sync/time-out-choice/timeout" {
              description
                "Wait for the specified number of seconds for the lock
                 to be placed in the queue. If no timeout is set,
                 the action waits indefinitely.";
            }
            refine "block-others" {
              description
                "The lock will block other items, using any of the devices
                 in the lock, to enter the commit queue.";
            }
          }
          leaf-list device {
            type string;
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:name";
            }
            min-elements 1;
          }
        }
        output {
          leaf commit-queue-id {
            type uint64;
            description
              "The operation was successful, the lock is now in place.
               To unlock the queue item see the action
               /devices/commit-queue/queue-item/unlock.";
          }
          leaf result {
            type enumeration {
              enum timeout {
                tailf:code-name cq_add_lock_timeout;
                description
                  "A timeout occurred, the lock is not in place, the
                   operation was not successful.";
              }
              enum failed {
                tailf:code-name cq_add_lock_failed;
                description
                  "The queue item was manually unlocked or deleted, the
                   devices are not locked, the operation was not
                   successful";
              }
            }
          }
        }
      }
      list queue-item {
        tailf:display-groups "none details summary";
        tailf:info "An item in the commit-queue";
        tailf:callpoint ncs {
          tailf:internal;
        }
        key id;
        leaf id {
          type uint64;
          description
            "Unique id identifying a queue item.";
        }
        leaf tag {
          type string;
          description
            "Opaque string set at commit time. The 'tag' will be present in
             progress events sent about a queue item.";
        }
        leaf age {
          tailf:display-groups "none details summary";
          type uint32;
          units "seconds";
          description
            "The age in seconds of this queue item. How long time
             has this item been in the queue.";
        }
        uses queue-item-status;
        leaf kilo-bytes-size {
          tailf:display-groups "none details";
          type uint32;
          units "kiloBytes";
          description
            "The size in kiloBytes of this queue item.";
        }
        leaf-list devices {
          tailf:display-groups "none details summary";
          type leafref {
            path "/devices/device/name";
          }
          description
            "The names of the devices that are part of this queue
             item.";
        }
        leaf-list waiting-for {
          tailf:display-groups "none details summary";
          type leafref {
            path "/devices/device/name";
          }
          description
            "If this queue item's status is 'waiting', 'blocked' or
             'blocking', this leaf-list contains the devices the queue
             item is waiting for in order to execute.";
        }
        leaf-list transient-errors {
          tailf:display-groups "none details summary";
          type leafref {
            path "/devices/device/name";
          }
          description
            "This leaf-list contains devices with transient errors,
             e.g., connection problems or a locked device.  These
             devices can possibly block other queue items from being
             processed.";
        }
        leaf-list completed {
          tailf:display-groups "none details";
          type leafref {
            path "/devices/device/name";
          }
          description
            "The devices which are completed for this queue item.";
        }
        list remote-queue-item {
          key "node";
          leaf node {
            type leafref {
              path "/ncs:cluster/ncs:remote-node/ncs:name";
            }
            description
              "Parts of the queue-item has been distributed to this node.
               This is only present when using clusters.";
          }
          leaf id {
            type uint64;
            description
              "The is the id of the queue-item on the remote node.";
          }
        }
        leaf is-atomic {
          tailf:display-groups "none details";
          type boolean;
          description
            "Whether the queue item runs atomic or not.";
        }
        list modification {
          tailf:display-groups "details";
          key device;
          description
            "A detailed view of the queued modifications.";
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
            description
              "Name of the device.";
          }
          leaf data {
            tailf:display-groups "details";
            type string;
            description
              "Textual description of data queued to be sent.";
            tailf:cli-preformatted;
          }
          leaf local-user {
            tailf:display-groups "details";
            type string;
            description
              "Name of local NCS user that commited this data.";
          }
        }
        tailf:action delete {
          description
            "Delete this queue item. This will make the devices out-of-sync
             with NCS since the devices will never receive the
             configuration changes committed to NCS.";
          tailf:info "Delete this queue item";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
        }
        tailf:action lock {
          description
            "Put a lock on this queue item. This can only be performed
             when the queue item has status 'waiting' or 'blocked'.

             A lock can also be placed on a queue-item at commit time
             through the commit parameter 'queue/lock'.";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
        }
        tailf:action unlock {
          description
            "Unlock this queue item. For a queue item with status 'locked'
             the status will change to 'waiting', for all other statuses this
             action is ignored.";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
          input {
            leaf atomic {
              tailf:hidden full;
              type boolean;
            }
          }
        }
        tailf:action prune {
          description
            "Prune a queue item that contain any of the devices in
             the input. The devices will be removed from the queue item.
             If no devices remain the queue item will be deleted.
             If the queue item was part of a service transaction the
             service will be flagged as failed.";
          tailf:info "Prune a queue item";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
          input {
            leaf-list device {
              type leafref {
                path "/devices/device/name";
              }
            }
          }
        }
        tailf:action set-atomic-behaviour {
          description
            "Set the atomic behaviour of this queue item. If this is set to
             false, this queue item will process on other non-atomic
             queue items with completed devices.";
          tailf:info "Set the atomic behaviour of this queue item";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
          input {
            leaf atomic {
              type boolean;
              mandatory true;
            }
          }
        }
      }

      list qitem {
        tailf:hidden full;
        key cq-id;
        description
          "Hidden NCS private data used by the commit-queue.";

        tailf:cdb-oper {
          tailf:persistent true;
        }
        leaf cq-id {
          type uint64;
        }
        leaf cq-tag {
          type string;
          description
            "The tag of the commit";
        }
        leaf cq-locked {
          type boolean;
        }
        leaf cq-block-others {
          type boolean;
        }
        leaf cq-atomic {
          type boolean;
        }
        leaf cq-sentinel {
          type boolean;
        }
        leaf cq-data {
          type string;
          description
            "Persistent representation of a queue-item.";
        }
        list cq-completed {
          key dev;
          description
            "Which local and remote devices in this qitem are completed.";
          leaf dev {
            type string;
          }
        }
        list cq-failed {
          key dev;
          description
            "Which local and remote devices in this qitem has failed.";
          leaf dev {
            type string;
          }
          leaf reason {
            type string;
            description
              "A string representing the error for this failing device.";
          }
        }
      }
    }
  }

  notification ncs-commit-queue-progress-event {
    description
      "Generated for state changes in the internal NCS commit-queue.
       ";
    leaf id {
      type leafref {
        path "/devices/commit-queue/queue-item/id";
      }
      description
        "This value represents the queue item id in the commit-queue.
         The leafref is valid in the NCS which produced the event.";
    }
    leaf tag {
      type leafref {
        path "/devices/commit-queue/queue-item/tag";
      }
      description
        "Opaque tag set in the commit. The leafref is valid in the NCS which
         produced the event.";
    }
    leaf state {
      type enumeration {
        enum waiting {
          description
            "The queue item is waiting to run.  This state means
             that there is some other item in the queue, ahead of this item.";
        }
        enum executing {
          description
            "The queue item is currently executing at the
             head of the commit-queue.

             Still transient error can have occured when NCS tried to
             communicate with some of the devices. Such errors are
             shown in the transient-errors leaf-list.
             NCS will try to push down the changes after some time, as set in
             /devices/global-settings/commit-queue/
             connection-failure-reconnect-timer.

             Examples of transient errors are connection failures
             and that the changes are rejected due to the device
             being locked.

             Having transient errors are potentially bad, since the queue might
             grow if new items are added, waiting for the same device.";
        }
        enum locked {
          description
            "This queue item has been locked and waits to be unlocked.

             In a NCS cluster this is used as a synchronization mechanism
             between the different NCSes taking part in a transaction.";
          tailf:code-name 'cq_item_locked';
        }
        enum completed {
          description
          "The queue item was successfully completed.";
          tailf:code-name 'cq_item_completed';
        }
        enum failed {
          description
            "The queue item ended with a failing status.";
          tailf:code-name 'cq_item_failed';
        }
        enum deleted {
          description
          "The queue item was deleted from the queue.";
        }
      }
    }
    list completed-devices {
      key name;
      description
        "In the case of 'executing' notification type. This list contains the
         devices that has successfully finished since the previous executing
         notification for this commit-queue item.";
      leaf name {
        type string;
        description
          "A string representing a device.";
      }
    }
    list transient-devices {
      key name;
      description
        "In the case of a 'executing' notification, this list contains the
         devices for which a transient (temporary) error has occured.
         This list will be empty for all other notification types.";
      leaf name {
        type string;
        description
          "A string representing a device.";
      }
    }
    list failed-devices {
      key name;
      description
        "In the case of a 'executing' notification, this list contains all the
         currently known failed devices.
         For a 'failed' notification this list contains all failed devices.
         In the case of a 'deleted' notification that is emitted as a result of
         a prune action this list will contain the devices that are deleted.
         This list is empty in all other cases.";
      leaf name {
        type string;
        description
          "A string representing a device.";
      }
      leaf reason {
        type string;
        description
          "A string representing the error for this failing device.";
      }
    }
  }
}
